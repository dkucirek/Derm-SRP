---
title: "01: Joining and Cohort Definition"
output: html_document
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

### Load Libraries and Data

```{r}
library(readr)
library(tidyverse)
library(dplyr)
library(ggplot2)
library(readxl)
library(data.table)

data_path <- "Z:/Kucirek/"

demo_cols <- c("MRN_DEID", "race", "ethnic", "sex")
demo_data <- fread(file.path(data_path, "Data(Do not touch!)/dr_592588_demo.csv"), select = demo_cols)
setnames(demo_data, tolower(names(demo_data)))

# Depression
depression_cols <- c("MRN_DEID", "PHQ_DTTM", "PHQ_FIELD", "PHQ_VALUE")
depression_data <- fread(file.path(data_path, "Data(Do not touch!)/DR_592588_DEPRESSION.txt"), select = depression_cols)
setnames(depression_data, tolower(names(depression_data)))

encounter_cols <- c("MRN_DEID", "age_at_encounter", "FIN_CLASS", "APPT_DEPT", "ICD10_DX", "ICD_DIAGNOSIS", "ENC_DATE")

#age >= 18 
encounters_data <- fread(
  file.path(data_path, "Data(Do not touch!)/dr_592588_encounter.txt"),
  select = encounter_cols
)[age_at_encounter >= 18]

setnames(encounters_data, tolower(names(encounters_data)))
```

### Data Cleaning and Merging

```{r}
#convert to data.table, clean MRNs
datasets <- list(demo_data, depression_data, encounters_data)
lapply(datasets, setDT)
lapply(datasets, function(dt) dt[, mrn_deid := as.character(trimws(mrn_deid))])

# Keep unique MRNs in demo_data
demo_data <- unique(demo_data, by = "mrn_deid")

# Merge demo and depression data on MRN
dd_merged <- merge(demo_data, depression_data, by = "mrn_deid", all = FALSE)
setDT(dd_merged)
```

### Time-based Filtering

```{r}
# screening dates to date type, rename
dd_merged[, phq_date := as.Date(phq_dttm)]
encounters_data[, enc_date := as.Date(enc_date)]

# PHQ values to numeric 
dd_merged[, phq_value_num := fifelse(
  tolower(phq_value) %in% c("positive", "negative", ""),
  NA_real_,
  as.numeric(phq_value)
)]

# ±1 month window around screening dates
dd_merged[, `:=`(window_start = phq_date %m-% months(1), window_end = phq_date %m+% months(1))]
encounters_data[, `:=`(enc_start = enc_date, enc_end = enc_date)]

# set keys for data.table overlaps
setkey(dd_merged, mrn_deid, window_start, window_end)
setkey(encounters_data, mrn_deid, enc_start, enc_end)

# join encounters with screenings within ±1 month
result_all_matches <- foverlaps(encounters_data, dd_merged,
  by.x = c("mrn_deid", "enc_start", "enc_end"),
  by.y = c("mrn_deid", "window_start", "window_end"),
  type = "any", nomatch = 0L
)

# absolute date difference between encounter and screening
result_all_matches[, date_diff := abs(as.numeric(enc_date - phq_date))]

# keep closest screening for each (mrn, encounter, phq_field)
result_closest_all <- result_all_matches[
  order(mrn_deid, enc_date, phq_field, date_diff)
][
  , .SD[1], by = .(mrn_deid, enc_date, phq_field)
]

# str_to_title to fin_class before pivoting
result_closest_all[, fin_class := str_to_title(fin_class)]
result_closest_all[, phq_field := str_replace_all(phq_field, " ", "_")]
result_closest_all[, phq_field := make.names(phq_field)]

# pivot to wide: one row per (mrn, encounter)
# data.table's dcast() is faster than pivot_wider() for large data

cat("Number of rows to process:", nrow(result_closest_all), "\n")

phq_value_wide <- dcast(result_closest_all, 
                        mrn_deid + enc_date + age_at_encounter + fin_class + appt_dept + icd10_dx + icd_diagnosis + race + ethnic + sex ~ phq_field, 
                        value.var = "phq_value", 
                        fill = NA_character_,
                        fun.aggregate = function(x) x[1])  # take first value if duplicates

phq_value_num_wide <- dcast(result_closest_all[!is.na(phq_value_num)], 
                            mrn_deid + enc_date ~ phq_field, 
                            value.var = "phq_value_num", 
                            fill = NA_real_,
                            fun.aggregate = function(x) x[1])

phq_date_wide <- dcast(result_closest_all[!is.na(phq_date)], 
                       mrn_deid + enc_date ~ phq_field, 
                       value.var = "phq_date", 
                       fill = as.Date(NA),
                       fun.aggregate = function(x) x[1])

# rename columns
if (ncol(phq_value_num_wide) > 2) {
  setnames(phq_value_num_wide, 3:ncol(phq_value_num_wide), 
           paste0("phq_value_num_", names(phq_value_num_wide)[3:ncol(phq_value_num_wide)]))
}

if (ncol(phq_date_wide) > 2) {
  setnames(phq_date_wide, 3:ncol(phq_date_wide), 
           paste0("phq_date_", names(phq_date_wide)[3:ncol(phq_date_wide)]))
}

if (ncol(phq_value_wide) > 10) {
  setnames(phq_value_wide, 11:ncol(phq_value_wide), 
           paste0("phq_value_", names(phq_value_wide)[11:ncol(phq_value_wide)]))
}

# merge the three wide datasets using data.table joins
cat("Merging datasets...\n")
result_wide <- phq_value_wide

if (nrow(phq_value_num_wide) > 0) {
  result_wide <- merge(result_wide, phq_value_num_wide, 
                       by = c("mrn_deid", "enc_date"), 
                       all.x = TRUE)
}

if (nrow(phq_date_wide) > 0) {
  result_wide <- merge(result_wide, phq_date_wide, 
                       by = c("mrn_deid", "enc_date"), 
                       all.x = TRUE)
}

# back to data.table if needed
setDT(result_wide)

cat("Data reshaping complete. Final dimensions:", nrow(result_wide), "x", ncol(result_wide), "\n")

# standardize column names
cat("Standardizing column names...\n")

# batch renaming
column_mappings <- list(
  "phq_value_CMS.PHQ.2.POS.NEG" = "phq_value_CMS_PHQ-2_POS/NEG",
  "phq_value_CMS.PHQ.9.POS.NEG" = "phq_value_CMS_PHQ-9_POS/NEG", 
  "phq_value_num_PHQ.9.Total.Score" = "phq_value_num_PHQ-9_Total_Score",
  "phq_value_CMS PHQ-2 POS/NEG" = "phq_value_CMS_PHQ-2_POS/NEG",
  "phq_value_CMS PHQ-9 POS/NEG" = "phq_value_CMS_PHQ-9_POS/NEG",
  "phq_value_num_PHQ-9 Total Score" = "phq_value_num_PHQ-9_Total_Score"
)

# apply all mappings
for (old_name in names(column_mappings)) {
  if (old_name %in% names(result_wide)) {
    setnames(result_wide, old_name, column_mappings[[old_name]])
  }
}

cat("Column standardization complete.\n")

# --- manual PHQ-9 score calculation ---
phq9_items <- c(
  "phq_value_num_feeling tired or having little energy score",
  "phq_value_num_poor appetite or overeating score",
  "phq_value_num_little interest or pleasure in doing things score",
  "phq_value_num_feeling down, depressed, or hopeless score",
  "phq_value_num_moving or speaking so slowly that other people have noticed. Or the opposite score",
  "phq_value_num_feeling bad about yourself or that you are a failure or have let yourself or your family down score",
  "phq_value_num_thoughts that you would be better off dead or of hurting yourself score",
  "phq_value_num_trouble falling or staying asleep, or sleep too much score",
  "phq_value_num_trouble concentrating on things, such as reading the newspaper or watching television score"
)

# check if all item columns exist, initializing with NA if not 
for (item_col in phq9_items) {
  if (!(item_col %in% names(result_wide))) {
    result_wide <- result_wide %>% mutate(!!sym(item_col) := NA_real_)
  }
}

result_wide <- result_wide %>%
  mutate(
    n_items_present = rowSums(!is.na(across(all_of(phq9_items)))),
    phq9_manual_sum = case_when(
      n_items_present == 9 ~ rowSums(across(all_of(phq9_items)), na.rm = FALSE),
      TRUE ~ NA_real_
    )
  )

#Manual phq2 scoring 
# define the PHQ-2 column names
phq2_items <- c(
  "phq_value_num_little interest or pleasure in doing things score",
  "phq_value_num_feeling down, depressed, or hopeless score"
)

# make sure all item columns exist, initializing with NA if not 
for (item_col in phq2_items) {
  if (!(item_col %in% names(result_wide))) {
    result_wide <- result_wide %>% mutate(!!sym(item_col) := NA_real_)
  }
}

#  add columns for presence and manual sum if both items are present
result_wide <- result_wide %>%
  mutate(
    phq2_num_items_present = rowSums(!is.na(across(all_of(phq2_items)))),
    phq2_manual_sum = case_when(
      phq2_num_items_present == length(phq2_items) ~ rowSums(across(all_of(phq2_items)), na.rm = FALSE),
      TRUE ~ NA_real_
    )
  )

# define manual POS/NEG based on a sum >= 3 
result_wide <- result_wide %>%
  mutate(
    phq2_manual_posneg = case_when(
      is.na(phq2_manual_sum) ~ NA_character_,
      phq2_manual_sum >= 3 ~ "Positive",
      phq2_manual_sum < 3 ~ "Negative"
    )
  )

setDT(result_wide) # convert back to data.table 
```

### Define and Save Cohorts

```{r}
# define ICD-10 codes and diagnosis strings for chronic conditions
chronic_condition_icd_codes <- list(
  "Scarring Alopecia" = "L66",
  "Acne" = "L70",
  "Atopic Dermatitis" = "L20",
  "Hidradenitis Suppurativa" = "L73.2",
  "Rosacea" = "L71",
  "Vitiligo" = "L80",
  "Alopecia Areata" = "L63",
  "Psoriasis" = "L40",
  "Lupus Erythematosus" = c("L93", "M32.1", "M32.9")
)

# make one regex pattern from all codes for efficient filtering (text string used to define search pattern)
all_chronic_codes <- unlist(chronic_condition_icd_codes)
chronic_pattern <- paste(all_chronic_codes, collapse = "|")

# --- define chronic derm cohort based on ICD-10 Codes ---
chronic_derm_cohort <- result_wide[str_detect(icd10_dx, chronic_pattern)]

# create derm Clinic Cohort
derm_clinic_cohort <- result_wide[str_detect(tolower(appt_dept), "derm") & !str_detect(tolower(appt_dept), "ped")]

data_path <- "Z:/Kucirek/"

#save intermediate files
saveRDS(result_wide, file.path(data_path, "result_wide.rds"))
saveRDS(chronic_derm_cohort, file.path(data_path, "chronic_derm_cohort.rds"))
saveRDS(derm_clinic_cohort, file.path(data_path, "derm_clinic_cohort.rds"))


cat(paste("Intermediate data files saved to:", data_path, "\n"))
```
